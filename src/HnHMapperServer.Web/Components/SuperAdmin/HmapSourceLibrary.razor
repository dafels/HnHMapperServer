@using HnHMapperServer.Core.DTOs
@inject IHttpClientFactory HttpClientFactory
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@inject ILogger<HmapSourceLibrary> Logger

<MudPaper Class="pa-4">
    <MudStack Spacing="3">
        <div class="d-flex justify-space-between align-center">
            <MudText Typo="Typo.h5">
                <MudIcon Icon="@Icons.Material.Filled.Storage" Class="me-2" />
                HMap Source Library
            </MudText>
            <MudStack Row="true" Spacing="2">
                <MudButton Variant="Variant.Filled"
                          Color="Color.Primary"
                          StartIcon="@Icons.Material.Filled.Refresh"
                          OnClick="LoadSources"
                          Disabled="@_isLoading">
                    Refresh
                </MudButton>
            </MudStack>
        </div>

        <MudAlert Severity="Severity.Info" Dense="true">
            <MudIcon Icon="@Icons.Material.Filled.Info" Size="Size.Small" Class="me-1" />
            Upload .hmap files to use as sources for public map generation. Sources can be reused across multiple public maps.
        </MudAlert>

        <!-- Upload Section -->
        <MudPaper Elevation="0" Class="pa-3 mud-background-gray">
            <MudStack Spacing="2">
                <MudText Typo="Typo.subtitle1">Upload New HMap Source</MudText>
                <MudStack Row="true" Spacing="2" AlignItems="AlignItems.End">
                    <MudTextField @bind-Value="_uploadName"
                                 Label="Name (optional)"
                                 Variant="Variant.Outlined"
                                 HelperText="Display name for this source"
                                 Style="max-width: 300px;" />
                    <MudFileUpload T="IBrowserFile"
                                  FilesChanged="OnFileSelected"
                                  Accept=".hmap"
                                  MaximumFileCount="1"
                                  Disabled="@_isUploading">
                        <ActivatorContent>
                            <MudButton Variant="Variant.Filled"
                                      Color="Color.Success"
                                      StartIcon="@Icons.Material.Filled.CloudUpload"
                                      Disabled="@_isUploading">
                                @if (_isUploading)
                                {
                                    <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="me-2" />
                                    <span>Uploading...</span>
                                }
                                else
                                {
                                    <span>Select .hmap File</span>
                                }
                            </MudButton>
                        </ActivatorContent>
                    </MudFileUpload>
                </MudStack>
                @if (_selectedFile != null && !_isUploading)
                {
                    <MudStack Row="true" Spacing="2" AlignItems="AlignItems.Center">
                        <MudChip T="string" Icon="@Icons.Material.Filled.InsertDriveFile" Color="Color.Default">
                            @_selectedFile.Name (@FormatFileSize(_selectedFile.Size))
                        </MudChip>
                        <MudButton Variant="Variant.Filled"
                                  Color="Color.Primary"
                                  Size="Size.Small"
                                  OnClick="UploadFile">
                            Upload
                        </MudButton>
                        <MudButton Variant="Variant.Outlined"
                                  Color="Color.Default"
                                  Size="Size.Small"
                                  OnClick="ClearSelectedFile">
                            Cancel
                        </MudButton>
                    </MudStack>
                }
                @if (_uploadProgress > 0 && _isUploading)
                {
                    <MudProgressLinear Value="@_uploadProgress" Color="Color.Primary" />
                }
            </MudStack>
        </MudPaper>

        <!-- Sources List -->
        @if (_isLoading)
        {
            <MudProgressLinear Indeterminate="true" />
        }
        else if (!_sources.Any())
        {
            <MudAlert Severity="Severity.Info">
                No HMap sources uploaded yet. Upload .hmap files to use them as sources for public maps.
            </MudAlert>
        }
        else
        {
            <MudText Typo="Typo.subtitle1">Available Sources (@_sources.Count)</MudText>
            <MudTable T="HmapSourceDto" Items="@_sources" Hover="true" Dense="true">
                <HeaderContent>
                    <MudTh>Name</MudTh>
                    <MudTh>File</MudTh>
                    <MudTh>Grids</MudTh>
                    <MudTh>Bounds</MudTh>
                    <MudTh>Uploaded</MudTh>
                    <MudTh>Used By</MudTh>
                    <MudTh>Actions</MudTh>
                </HeaderContent>
                <RowTemplate>
                    <MudTd DataLabel="Name">
                        <MudText Typo="Typo.body2">@context.Name</MudText>
                    </MudTd>
                    <MudTd DataLabel="File">
                        <MudText Typo="Typo.body2">@context.FileName</MudText>
                        <MudText Typo="Typo.caption" Color="Color.Secondary">@context.FileSizeDisplay</MudText>
                    </MudTd>
                    <MudTd DataLabel="Grids">
                        @if (context.IsAnalyzed)
                        {
                            <MudText Typo="Typo.body2">@context.TotalGrids?.ToString("N0")</MudText>
                            @if (context.SegmentCount > 1)
                            {
                                <MudText Typo="Typo.caption" Color="Color.Secondary">@context.SegmentCount segments</MudText>
                            }
                        }
                        else
                        {
                            <MudChip T="string" Size="Size.Small" Color="Color.Warning">Not analyzed</MudChip>
                        }
                    </MudTd>
                    <MudTd DataLabel="Bounds">
                        @if (context.IsAnalyzed && context.MinX.HasValue)
                        {
                            <MudText Typo="Typo.body2">
                                X: @context.MinX to @context.MaxX
                            </MudText>
                            <MudText Typo="Typo.caption" Color="Color.Secondary">
                                Y: @context.MinY to @context.MaxY
                            </MudText>
                        }
                        else
                        {
                            <MudText Typo="Typo.body2" Color="Color.Secondary">-</MudText>
                        }
                    </MudTd>
                    <MudTd DataLabel="Uploaded">
                        <MudText Typo="Typo.body2">@context.UploadedAt.ToString("yyyy-MM-dd")</MudText>
                        @if (!string.IsNullOrEmpty(context.UploadedBy))
                        {
                            <MudText Typo="Typo.caption" Color="Color.Secondary">by @context.UploadedBy</MudText>
                        }
                    </MudTd>
                    <MudTd DataLabel="Used By">
                        @{
                            var usageCount = GetUsageCount(context.Id);
                        }
                        @if (usageCount > 0)
                        {
                            <MudChip T="string" Size="Size.Small" Color="Color.Info">
                                @usageCount map@(usageCount > 1 ? "s" : "")
                            </MudChip>
                        }
                        else
                        {
                            <MudChip T="string" Size="Size.Small" Color="Color.Default">Unused</MudChip>
                        }
                    </MudTd>
                    <MudTd DataLabel="Actions">
                        <MudStack Row="true" Spacing="1">
                            <MudTooltip Text="Re-analyze">
                                <MudIconButton Icon="@Icons.Material.Filled.Analytics"
                                              Color="Color.Info"
                                              Size="Size.Small"
                                              OnClick="@(() => AnalyzeSource(context))"
                                              Disabled="@_isAnalyzing" />
                            </MudTooltip>
                            <MudTooltip Text="@(GetUsageCount(context.Id) > 0 ? "Cannot delete - in use" : "Delete")">
                                <MudIconButton Icon="@Icons.Material.Filled.Delete"
                                              Color="Color.Error"
                                              Size="Size.Small"
                                              OnClick="@(() => DeleteSource(context))"
                                              Disabled="@(GetUsageCount(context.Id) > 0)" />
                            </MudTooltip>
                        </MudStack>
                    </MudTd>
                </RowTemplate>
            </MudTable>
        }
    </MudStack>
</MudPaper>

@code {
    private List<HmapSourceDto> _sources = new();
    private Dictionary<int, int> _sourceUsageCounts = new();
    private bool _isLoading = true;
    private bool _isUploading = false;
    private bool _isAnalyzing = false;
    private int _uploadProgress = 0;

    private string? _uploadName;
    private IBrowserFile? _selectedFile;

    protected override async Task OnInitializedAsync()
    {
        await LoadSources();
    }

    private async Task LoadSources()
    {
        _isLoading = true;
        StateHasChanged();

        try
        {
            var client = HttpClientFactory.CreateClient("API");

            // Load sources
            var sourcesResponse = await client.GetAsync("/api/superadmin/hmap-sources");
            if (sourcesResponse.IsSuccessStatusCode)
            {
                _sources = await sourcesResponse.Content.ReadFromJsonAsync<List<HmapSourceDto>>(
                    new System.Text.Json.JsonSerializerOptions { PropertyNameCaseInsensitive = true }) ?? new();
            }
            else
            {
                Snackbar.Add("Failed to load HMap sources", Severity.Error);
            }

            // Load usage counts (which public maps use each source)
            await LoadSourceUsageCounts();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading HMap sources");
            Snackbar.Add("Error loading HMap sources", Severity.Error);
        }
        finally
        {
            _isLoading = false;
            StateHasChanged();
        }
    }

    private async Task LoadSourceUsageCounts()
    {
        _sourceUsageCounts.Clear();
        var client = HttpClientFactory.CreateClient("API");

        // Get all public maps and count source usage
        var publicMapsResponse = await client.GetAsync("/api/superadmin/public-maps");
        if (publicMapsResponse.IsSuccessStatusCode)
        {
            var publicMaps = await publicMapsResponse.Content.ReadFromJsonAsync<List<PublicMapDto>>(
                new System.Text.Json.JsonSerializerOptions { PropertyNameCaseInsensitive = true }) ?? new();

            foreach (var publicMap in publicMaps)
            {
                // Get hmap sources for this public map
                var hmapSourcesResponse = await client.GetAsync($"/api/superadmin/public-maps/{publicMap.Id}/hmap-sources");
                if (hmapSourcesResponse.IsSuccessStatusCode)
                {
                    var hmapSources = await hmapSourcesResponse.Content.ReadFromJsonAsync<List<PublicMapHmapSourceDto>>(
                        new System.Text.Json.JsonSerializerOptions { PropertyNameCaseInsensitive = true }) ?? new();

                    foreach (var source in hmapSources)
                    {
                        if (!_sourceUsageCounts.ContainsKey(source.HmapSourceId))
                            _sourceUsageCounts[source.HmapSourceId] = 0;
                        _sourceUsageCounts[source.HmapSourceId]++;
                    }
                }
            }
        }
    }

    private int GetUsageCount(int sourceId)
    {
        return _sourceUsageCounts.TryGetValue(sourceId, out var count) ? count : 0;
    }

    private void OnFileSelected(IBrowserFile? file)
    {
        _selectedFile = file;
        StateHasChanged();
    }

    private void ClearSelectedFile()
    {
        _selectedFile = null;
        _uploadName = null;
        StateHasChanged();
    }

    private async Task UploadFile()
    {
        if (_selectedFile == null) return;

        _isUploading = true;
        _uploadProgress = 0;
        StateHasChanged();

        try
        {
            var client = HttpClientFactory.CreateClient("API");

            using var content = new MultipartFormDataContent();

            // Read file with progress tracking
            var maxFileSize = 500 * 1024 * 1024L; // 500MB max
            using var stream = _selectedFile.OpenReadStream(maxFileSize);
            using var memoryStream = new MemoryStream();

            var buffer = new byte[81920];
            var totalRead = 0L;
            int read;
            while ((read = await stream.ReadAsync(buffer, 0, buffer.Length)) > 0)
            {
                await memoryStream.WriteAsync(buffer, 0, read);
                totalRead += read;
                _uploadProgress = (int)(totalRead * 100 / _selectedFile.Size);
                StateHasChanged();
            }

            memoryStream.Position = 0;
            var fileContent = new StreamContent(memoryStream);
            fileContent.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue("application/octet-stream");
            content.Add(fileContent, "file", _selectedFile.Name);

            if (!string.IsNullOrWhiteSpace(_uploadName))
            {
                content.Add(new StringContent(_uploadName), "name");
            }

            var response = await client.PostAsync("/api/superadmin/hmap-sources", content);

            if (response.IsSuccessStatusCode)
            {
                Snackbar.Add($"Uploaded '{_selectedFile.Name}' successfully", Severity.Success);
                ClearSelectedFile();
                await LoadSources();
            }
            else
            {
                var errorBody = await response.Content.ReadAsStringAsync();
                try
                {
                    var errorObj = System.Text.Json.JsonSerializer.Deserialize<ErrorResponse>(errorBody,
                        new System.Text.Json.JsonSerializerOptions { PropertyNameCaseInsensitive = true });
                    Snackbar.Add(errorObj?.Error ?? "Failed to upload file", Severity.Error);
                }
                catch
                {
                    Snackbar.Add("Failed to upload file", Severity.Error);
                }
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error uploading HMap file");
            Snackbar.Add($"Error: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isUploading = false;
            _uploadProgress = 0;
            StateHasChanged();
        }
    }

    private async Task AnalyzeSource(HmapSourceDto source)
    {
        _isAnalyzing = true;
        StateHasChanged();

        try
        {
            var client = HttpClientFactory.CreateClient("API");
            var response = await client.PostAsync($"/api/superadmin/hmap-sources/{source.Id}/analyze", null);

            if (response.IsSuccessStatusCode)
            {
                Snackbar.Add($"Analyzed '{source.Name}'", Severity.Success);
                await LoadSources();
            }
            else
            {
                Snackbar.Add("Failed to analyze source", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error analyzing HMap source {SourceId}", source.Id);
            Snackbar.Add($"Error: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isAnalyzing = false;
            StateHasChanged();
        }
    }

    private async Task DeleteSource(HmapSourceDto source)
    {
        var usageCount = GetUsageCount(source.Id);
        if (usageCount > 0)
        {
            Snackbar.Add($"Cannot delete - source is used by {usageCount} public map(s)", Severity.Warning);
            return;
        }

        var confirmed = await DialogService.ShowMessageBox(
            "Delete HMap Source",
            $"Are you sure you want to delete '{source.Name}' ({source.FileName})? This will also delete the file from storage.",
            "Delete", cancelText: "Cancel");

        if (confirmed == true)
        {
            try
            {
                var client = HttpClientFactory.CreateClient("API");
                var response = await client.DeleteAsync($"/api/superadmin/hmap-sources/{source.Id}");

                if (response.IsSuccessStatusCode)
                {
                    Snackbar.Add($"Deleted '{source.Name}'", Severity.Success);
                    await LoadSources();
                }
                else if (response.StatusCode == System.Net.HttpStatusCode.Conflict)
                {
                    Snackbar.Add("Cannot delete - source is in use by public maps", Severity.Warning);
                }
                else
                {
                    Snackbar.Add("Failed to delete source", Severity.Error);
                }
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error deleting HMap source {SourceId}", source.Id);
                Snackbar.Add($"Error: {ex.Message}", Severity.Error);
            }
        }
    }

    private static string FormatFileSize(long bytes)
    {
        if (bytes < 1024) return $"{bytes} B";
        if (bytes < 1024 * 1024) return $"{bytes / 1024.0:F1} KB";
        if (bytes < 1024 * 1024 * 1024) return $"{bytes / (1024.0 * 1024.0):F1} MB";
        return $"{bytes / (1024.0 * 1024.0 * 1024.0):F2} GB";
    }

    private class ErrorResponse
    {
        public string Error { get; set; } = string.Empty;
    }
}
