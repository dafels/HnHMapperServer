@using HnHMapperServer.Core.DTOs
@inject IHttpClientFactory HttpClientFactory
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@inject ILogger<HmapSourceLibrary> Logger

<MudPaper Class="pa-4">
    <MudStack Spacing="3">
        <div class="d-flex justify-space-between align-center">
            <MudText Typo="Typo.h5">
                <MudIcon Icon="@Icons.Material.Filled.Storage" Class="me-2" />
                HMap Source Library
            </MudText>
            <MudStack Row="true" Spacing="2">
                <MudButton Variant="Variant.Filled"
                          Color="Color.Primary"
                          StartIcon="@Icons.Material.Filled.Refresh"
                          OnClick="LoadSources"
                          Disabled="@_isLoading">
                    Refresh
                </MudButton>
            </MudStack>
        </div>

        <MudAlert Severity="Severity.Info" Dense="true">
            <MudIcon Icon="@Icons.Material.Filled.Info" Size="Size.Small" Class="me-1" />
            Upload .hmap files to use as sources for public map generation. Sources can be reused across multiple public maps.
        </MudAlert>

        <!-- Upload Section -->
        <MudPaper Elevation="0" Class="pa-3 mud-background-gray">
            <MudStack Spacing="2">
                <MudText Typo="Typo.subtitle1">Upload HMap Sources</MudText>
                <MudStack Row="true" Spacing="2" AlignItems="AlignItems.Center">
                    <MudFileUpload T="IReadOnlyList<IBrowserFile>"
                                  FilesChanged="OnFilesSelected"
                                  Accept=".hmap"
                                  Disabled="@_isUploading">
                        <ActivatorContent>
                            <MudButton Variant="Variant.Filled"
                                      Color="Color.Success"
                                      StartIcon="@Icons.Material.Filled.CloudUpload"
                                      Disabled="@_isUploading">
                                @if (_isUploading)
                                {
                                    <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="me-2" />
                                    <span>Uploading...</span>
                                }
                                else
                                {
                                    <span>Select .hmap Files</span>
                                }
                            </MudButton>
                        </ActivatorContent>
                    </MudFileUpload>
                    <MudText Typo="Typo.caption" Color="Color.Secondary">
                        Hold Ctrl or Shift to select multiple files
                    </MudText>
                </MudStack>
                @if (_selectedFiles.Any() && !_isUploading)
                {
                    <MudStack Spacing="1">
                        <MudText Typo="Typo.body2">@_selectedFiles.Count file(s) selected:</MudText>
                        <MudStack Row="true" Spacing="1" Class="flex-wrap">
                            @foreach (var file in _selectedFiles)
                            {
                                <MudChip T="string"
                                        Icon="@Icons.Material.Filled.InsertDriveFile"
                                        Color="Color.Default"
                                        Size="Size.Small"
                                        OnClose="@(() => RemoveSelectedFile(file))">
                                    @file.Name (@FormatFileSize(file.Size))
                                </MudChip>
                            }
                        </MudStack>
                        <MudStack Row="true" Spacing="2" AlignItems="AlignItems.Center">
                            <MudButton Variant="Variant.Filled"
                                      Color="Color.Primary"
                                      Size="Size.Small"
                                      OnClick="UploadFiles">
                                Upload All (@_selectedFiles.Count)
                            </MudButton>
                            <MudButton Variant="Variant.Outlined"
                                      Color="Color.Default"
                                      Size="Size.Small"
                                      OnClick="ClearSelectedFiles">
                                Clear All
                            </MudButton>
                        </MudStack>
                    </MudStack>
                }
                @if (_isUploading)
                {
                    <MudStack Spacing="1">
                        <MudText Typo="Typo.body2">
                            Uploading @(_currentUploadIndex + 1) of @_totalFilesToUpload: @_currentUploadFileName
                        </MudText>
                        <MudProgressLinear Value="@_uploadProgress" Color="Color.Primary" />
                    </MudStack>
                }
            </MudStack>
        </MudPaper>

        <!-- Sources List -->
        @if (_isLoading)
        {
            <MudProgressLinear Indeterminate="true" />
        }
        else if (!_sources.Any())
        {
            <MudAlert Severity="Severity.Info">
                No HMap sources uploaded yet. Upload .hmap files to use them as sources for public maps.
            </MudAlert>
        }
        else
        {
            <MudText Typo="Typo.subtitle1">Available Sources (@_sources.Count)</MudText>
            <MudTable T="HmapSourceDto" Items="@_sources" Hover="true" Dense="true">
                <HeaderContent>
                    <MudTh>Name</MudTh>
                    <MudTh>File</MudTh>
                    <MudTh>Grids</MudTh>
                    <MudTh>Bounds</MudTh>
                    <MudTh>Uploaded</MudTh>
                    <MudTh>Used By</MudTh>
                    <MudTh>Actions</MudTh>
                </HeaderContent>
                <RowTemplate>
                    <MudTd DataLabel="Name">
                        <MudText Typo="Typo.body2">@context.Name</MudText>
                    </MudTd>
                    <MudTd DataLabel="File">
                        <MudText Typo="Typo.body2">@context.FileName</MudText>
                        <MudText Typo="Typo.caption" Color="Color.Secondary">@context.FileSizeDisplay</MudText>
                    </MudTd>
                    <MudTd DataLabel="Grids">
                        @if (context.IsAnalyzed)
                        {
                            <MudText Typo="Typo.body2">@context.TotalGrids?.ToString("N0")</MudText>
                            @if (context.SegmentCount > 1)
                            {
                                <MudText Typo="Typo.caption" Color="Color.Secondary">@context.SegmentCount segments</MudText>
                            }
                        }
                        else
                        {
                            <MudChip T="string" Size="Size.Small" Color="Color.Warning">Not analyzed</MudChip>
                        }
                    </MudTd>
                    <MudTd DataLabel="Bounds">
                        @if (context.IsAnalyzed && context.MinX.HasValue)
                        {
                            <MudText Typo="Typo.body2">
                                X: @context.MinX to @context.MaxX
                            </MudText>
                            <MudText Typo="Typo.caption" Color="Color.Secondary">
                                Y: @context.MinY to @context.MaxY
                            </MudText>
                        }
                        else
                        {
                            <MudText Typo="Typo.body2" Color="Color.Secondary">-</MudText>
                        }
                    </MudTd>
                    <MudTd DataLabel="Uploaded">
                        <MudText Typo="Typo.body2">@context.UploadedAt.ToString("yyyy-MM-dd")</MudText>
                        @if (!string.IsNullOrEmpty(context.UploadedBy))
                        {
                            <MudText Typo="Typo.caption" Color="Color.Secondary">by @context.UploadedBy</MudText>
                        }
                    </MudTd>
                    <MudTd DataLabel="Used By">
                        @{
                            var usageCount = GetUsageCount(context.Id);
                        }
                        @if (usageCount > 0)
                        {
                            <MudChip T="string" Size="Size.Small" Color="Color.Info">
                                @usageCount map@(usageCount > 1 ? "s" : "")
                            </MudChip>
                        }
                        else
                        {
                            <MudChip T="string" Size="Size.Small" Color="Color.Default">Unused</MudChip>
                        }
                    </MudTd>
                    <MudTd DataLabel="Actions">
                        <MudStack Row="true" Spacing="1">
                            <MudTooltip Text="Re-analyze">
                                <MudIconButton Icon="@Icons.Material.Filled.Analytics"
                                              Color="Color.Info"
                                              Size="Size.Small"
                                              OnClick="@(() => AnalyzeSource(context))"
                                              Disabled="@_isAnalyzing" />
                            </MudTooltip>
                            <MudTooltip Text="@(GetUsageCount(context.Id) > 0 ? "Cannot delete - in use" : "Delete")">
                                <MudIconButton Icon="@Icons.Material.Filled.Delete"
                                              Color="Color.Error"
                                              Size="Size.Small"
                                              OnClick="@(() => DeleteSource(context))"
                                              Disabled="@(GetUsageCount(context.Id) > 0)" />
                            </MudTooltip>
                        </MudStack>
                    </MudTd>
                </RowTemplate>
            </MudTable>
        }
    </MudStack>
</MudPaper>

@code {
    private List<HmapSourceDto> _sources = new();
    private Dictionary<int, int> _sourceUsageCounts = new();
    private bool _isLoading = true;
    private bool _isUploading = false;
    private bool _isAnalyzing = false;
    private int _uploadProgress = 0;

    // Multi-file upload state
    private List<IBrowserFile> _selectedFiles = new();
    private int _currentUploadIndex = 0;
    private int _totalFilesToUpload = 0;
    private string _currentUploadFileName = "";

    protected override async Task OnInitializedAsync()
    {
        await LoadSources();
    }

    private async Task LoadSources()
    {
        _isLoading = true;
        StateHasChanged();

        try
        {
            var client = HttpClientFactory.CreateClient("API");

            // Load sources
            var sourcesResponse = await client.GetAsync("/api/superadmin/hmap-sources");
            if (sourcesResponse.IsSuccessStatusCode)
            {
                _sources = await sourcesResponse.Content.ReadFromJsonAsync<List<HmapSourceDto>>(
                    new System.Text.Json.JsonSerializerOptions { PropertyNameCaseInsensitive = true }) ?? new();
            }
            else
            {
                Snackbar.Add("Failed to load HMap sources", Severity.Error);
            }

            // Load usage counts (which public maps use each source)
            await LoadSourceUsageCounts();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading HMap sources");
            Snackbar.Add("Error loading HMap sources", Severity.Error);
        }
        finally
        {
            _isLoading = false;
            StateHasChanged();
        }
    }

    private async Task LoadSourceUsageCounts()
    {
        _sourceUsageCounts.Clear();
        var client = HttpClientFactory.CreateClient("API");

        // Get all public maps and count source usage
        var publicMapsResponse = await client.GetAsync("/api/superadmin/public-maps");
        if (publicMapsResponse.IsSuccessStatusCode)
        {
            var publicMaps = await publicMapsResponse.Content.ReadFromJsonAsync<List<PublicMapDto>>(
                new System.Text.Json.JsonSerializerOptions { PropertyNameCaseInsensitive = true }) ?? new();

            foreach (var publicMap in publicMaps)
            {
                // Get hmap sources for this public map
                var hmapSourcesResponse = await client.GetAsync($"/api/superadmin/public-maps/{publicMap.Id}/hmap-sources");
                if (hmapSourcesResponse.IsSuccessStatusCode)
                {
                    var hmapSources = await hmapSourcesResponse.Content.ReadFromJsonAsync<List<PublicMapHmapSourceDto>>(
                        new System.Text.Json.JsonSerializerOptions { PropertyNameCaseInsensitive = true }) ?? new();

                    foreach (var source in hmapSources)
                    {
                        if (!_sourceUsageCounts.ContainsKey(source.HmapSourceId))
                            _sourceUsageCounts[source.HmapSourceId] = 0;
                        _sourceUsageCounts[source.HmapSourceId]++;
                    }
                }
            }
        }
    }

    private int GetUsageCount(int sourceId)
    {
        return _sourceUsageCounts.TryGetValue(sourceId, out var count) ? count : 0;
    }

    private void OnFilesSelected(IReadOnlyList<IBrowserFile>? files)
    {
        if (files != null && files.Any())
        {
            // Add new files to the list (avoiding duplicates by name)
            foreach (var file in files)
            {
                if (!_selectedFiles.Any(f => f.Name == file.Name))
                {
                    _selectedFiles.Add(file);
                }
            }
        }
        StateHasChanged();
    }

    private void RemoveSelectedFile(IBrowserFile file)
    {
        _selectedFiles.Remove(file);
        StateHasChanged();
    }

    private void ClearSelectedFiles()
    {
        _selectedFiles.Clear();
        StateHasChanged();
    }

    private async Task UploadFiles()
    {
        if (!_selectedFiles.Any()) return;

        _isUploading = true;
        _uploadProgress = 0;
        _totalFilesToUpload = _selectedFiles.Count;
        _currentUploadIndex = 0;

        var filesToUpload = _selectedFiles.ToList(); // Copy to avoid modification during iteration
        var successCount = 0;
        var failedFiles = new List<string>();

        StateHasChanged();

        try
        {
            var client = HttpClientFactory.CreateClient("API");
            var maxFileSize = 500 * 1024 * 1024L; // 500MB max

            foreach (var file in filesToUpload)
            {
                _currentUploadFileName = file.Name;
                _uploadProgress = 0;
                StateHasChanged();

                try
                {
                    using var content = new MultipartFormDataContent();

                    // Read file with progress tracking
                    using var stream = file.OpenReadStream(maxFileSize);
                    using var memoryStream = new MemoryStream();

                    var buffer = new byte[81920];
                    var totalRead = 0L;
                    int read;
                    while ((read = await stream.ReadAsync(buffer, 0, buffer.Length)) > 0)
                    {
                        await memoryStream.WriteAsync(buffer, 0, read);
                        totalRead += read;
                        _uploadProgress = (int)(totalRead * 100 / file.Size);
                        StateHasChanged();
                    }

                    memoryStream.Position = 0;
                    var fileContent = new StreamContent(memoryStream);
                    fileContent.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue("application/octet-stream");
                    content.Add(fileContent, "file", file.Name);

                    var response = await client.PostAsync("/api/superadmin/hmap-sources", content);

                    if (response.IsSuccessStatusCode)
                    {
                        successCount++;
                    }
                    else
                    {
                        failedFiles.Add(file.Name);
                        var errorBody = await response.Content.ReadAsStringAsync();
                        try
                        {
                            var errorObj = System.Text.Json.JsonSerializer.Deserialize<ErrorResponse>(errorBody,
                                new System.Text.Json.JsonSerializerOptions { PropertyNameCaseInsensitive = true });
                            Logger.LogWarning("Failed to upload {FileName}: {Error}", file.Name, errorObj?.Error);
                        }
                        catch
                        {
                            Logger.LogWarning("Failed to upload {FileName}", file.Name);
                        }
                    }
                }
                catch (Exception ex)
                {
                    failedFiles.Add(file.Name);
                    Logger.LogError(ex, "Error uploading HMap file {FileName}", file.Name);
                }

                _currentUploadIndex++;
            }

            // Show summary
            if (successCount > 0 && failedFiles.Count == 0)
            {
                Snackbar.Add($"Successfully uploaded {successCount} file(s)", Severity.Success);
            }
            else if (successCount > 0 && failedFiles.Count > 0)
            {
                Snackbar.Add($"Uploaded {successCount} file(s), {failedFiles.Count} failed", Severity.Warning);
            }
            else
            {
                Snackbar.Add($"Failed to upload all {failedFiles.Count} file(s)", Severity.Error);
            }

            ClearSelectedFiles();
            await LoadSources();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error during batch upload");
            Snackbar.Add($"Error: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isUploading = false;
            _uploadProgress = 0;
            _currentUploadIndex = 0;
            _totalFilesToUpload = 0;
            _currentUploadFileName = "";
            StateHasChanged();
        }
    }

    private async Task AnalyzeSource(HmapSourceDto source)
    {
        _isAnalyzing = true;
        StateHasChanged();

        try
        {
            var client = HttpClientFactory.CreateClient("API");
            var response = await client.PostAsync($"/api/superadmin/hmap-sources/{source.Id}/analyze", null);

            if (response.IsSuccessStatusCode)
            {
                Snackbar.Add($"Analyzed '{source.Name}'", Severity.Success);
                await LoadSources();
            }
            else
            {
                Snackbar.Add("Failed to analyze source", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error analyzing HMap source {SourceId}", source.Id);
            Snackbar.Add($"Error: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isAnalyzing = false;
            StateHasChanged();
        }
    }

    private async Task DeleteSource(HmapSourceDto source)
    {
        var usageCount = GetUsageCount(source.Id);
        if (usageCount > 0)
        {
            Snackbar.Add($"Cannot delete - source is used by {usageCount} public map(s)", Severity.Warning);
            return;
        }

        var confirmed = await DialogService.ShowMessageBox(
            "Delete HMap Source",
            $"Are you sure you want to delete '{source.Name}' ({source.FileName})? This will also delete the file from storage.",
            "Delete", cancelText: "Cancel");

        if (confirmed == true)
        {
            try
            {
                var client = HttpClientFactory.CreateClient("API");
                var response = await client.DeleteAsync($"/api/superadmin/hmap-sources/{source.Id}");

                if (response.IsSuccessStatusCode)
                {
                    Snackbar.Add($"Deleted '{source.Name}'", Severity.Success);
                    await LoadSources();
                }
                else if (response.StatusCode == System.Net.HttpStatusCode.Conflict)
                {
                    Snackbar.Add("Cannot delete - source is in use by public maps", Severity.Warning);
                }
                else
                {
                    Snackbar.Add("Failed to delete source", Severity.Error);
                }
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error deleting HMap source {SourceId}", source.Id);
                Snackbar.Add($"Error: {ex.Message}", Severity.Error);
            }
        }
    }

    private static string FormatFileSize(long bytes)
    {
        if (bytes < 1024) return $"{bytes} B";
        if (bytes < 1024 * 1024) return $"{bytes / 1024.0:F1} KB";
        if (bytes < 1024 * 1024 * 1024) return $"{bytes / (1024.0 * 1024.0):F1} MB";
        return $"{bytes / (1024.0 * 1024.0 * 1024.0):F2} GB";
    }

    private class ErrorResponse
    {
        public string Error { get; set; } = string.Empty;
    }
}
